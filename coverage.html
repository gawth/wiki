
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>wiki: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gawth/wiki/api.go (79.2%)</option>
				
				<option value="file1">github.com/gawth/wiki/config.go (0.0%)</option>
				
				<option value="file2">github.com/gawth/wiki/nav.go (46.4%)</option>
				
				<option value="file3">github.com/gawth/wiki/pub.go (0.0%)</option>
				
				<option value="file4">github.com/gawth/wiki/search.go (100.0%)</option>
				
				<option value="file5">github.com/gawth/wiki/secure.go (71.4%)</option>
				
				<option value="file6">github.com/gawth/wiki/storage.go (76.2%)</option>
				
				<option value="file7">github.com/gawth/wiki/storage_cached.go (68.2%)</option>
				
				<option value="file8">github.com/gawth/wiki/storage_stub.go (61.9%)</option>
				
				<option value="file9">github.com/gawth/wiki/tags.go (92.3%)</option>
				
				<option value="file10">github.com/gawth/wiki/wiki.go (47.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "encoding/json"
        "io"
        "log"
        "net/http"
        "path/filepath"
        "strings"
)

func apiHandler(fn func(http.ResponseWriter, *http.Request, storage), s storage) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                fn(w, r, s)
        }</span>
}

func handleTag(w http.ResponseWriter, r *http.Request, s storage) bool <span class="cov8" title="1">{
        tag := r.URL.Query().Get("tag") // Get the tag
        // Just return an empty response if no tag found
        if tag == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">data := s.GetTagWikis(tag)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(data)
        return true</span>
}
func handleGetWiki(w http.ResponseWriter, r *http.Request, s storage) bool <span class="cov8" title="1">{
        if r.Method != "GET" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">wiki := r.URL.Query().Get("wiki") // Get the wiki
        if wiki == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">wikipg := &amp;wikiPage{basePage: basePage{Title: wiki}}
        wikipg, err := s.getPage(wikipg)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(wikipg)
        return true</span>
}
func handlePostWiki(w http.ResponseWriter, r *http.Request, s storage) bool <span class="cov8" title="1">{
        if r.Method != "POST" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">wiki := r.URL.Query().Get("wiki") // Get the wiki
        if wiki == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return false
        }</span>

        <span class="cov8" title="1">var wp wikiPage
        if err := json.Unmarshal(body, &amp;wp); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return false
        }</span>

        // TODO: Handle encryption and published pages

        <span class="cov8" title="1">err = wp.save(s)
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err)
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return false
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        return true</span>
}
func handleGetList(w http.ResponseWriter, r *http.Request, s storage) bool <span class="cov8" title="1">{
        if r.Method != "GET" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">list := r.URL.Query().Get("list") // Get the wiki list
        if list == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">data := s.getWikiList(list)

        if len(data) == 0 </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusNotFound)
        }</span> else<span class="cov8" title="1"> {
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                json.NewEncoder(w).Encode(data)
        }</span>

        <span class="cov8" title="1">return true</span>
}

func handleImageUpload(w http.ResponseWriter, r *http.Request, s storage) bool <span class="cov8" title="1">{
        // Extract wiki title from URL path
        parts := strings.Split(r.URL.Path, "/")
        
        if len(parts) &lt; 4 || parts[2] != "image" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">wikiTitle := parts[3]
        
        // Parse multipart form
        err := r.ParseMultipartForm(10 &lt;&lt; 20) // 10MB max
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return true
        }</span>
        
        // Get image file
        <span class="cov8" title="1">file, handler, err := r.FormFile("image")
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return true
        }</span>
        <span class="cov8" title="1">defer file.Close()
        
        // Read file data
        imageData, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return true
        }</span>
        
        // Get file extension or default to .png
        <span class="cov8" title="1">fileExt := filepath.Ext(handler.Filename)
        if fileExt == "" </span><span class="cov0" title="0">{
                fileExt = ".png"
        }</span>
        
        // Store image using storage interface
        <span class="cov8" title="1">imageURL, err := s.storeImage(wikiTitle, imageData, fileExt)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return true
        }</span>
        
        // Return URL to client
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"url": imageURL})
        
        return true</span>
}

func innerAPIHandler(w http.ResponseWriter, r *http.Request, s storage) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")

        // Add this before other handlers
        if strings.HasPrefix(r.URL.Path, "/api/image/") </span><span class="cov8" title="1">{
                if handleImageUpload(w, r, s) </span><span class="cov8" title="1">{
                        return
                }</span>
        }

        <span class="cov8" title="1">if ok := handleTag(w, r, s); ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if ok := handleGetWiki(w, r, s); ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if ok := handlePostWiki(w, r, s); ok </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if ok := handleGetList(w, r, s); ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusBadRequest)
        return</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "strconv"

        "github.com/thanhpk/randstr"
)

// Config object loaded from disk at startup
type Config struct {
        WikiDir       string
        Logfile       string
        HTTPPort      int
        EncryptionKey string
}

// getenv returns an env var if it is set or the default passed in
func getenv(key, fallback string) string <span class="cov0" title="0">{
        val := os.Getenv(key)
        if len(val) == 0 </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov0" title="0">return val</span>
}

// LoadConfig reads in config from file and hydrates to a
// config object
func LoadConfig() (*Config, error) <span class="cov0" title="0">{
        path := "config.json"
        config := Config{
                WikiDir:  "./wikidir",
                HTTPPort: 8080,
        }
        conf, err := ioutil.ReadFile(path)
        if err == nil </span><span class="cov0" title="0">{
                log.Printf("Using config file")
                err = json.Unmarshal(conf, &amp;config)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">config.HTTPPort, _ = strconv.Atoi(getenv("PORT", strconv.Itoa(config.HTTPPort)))
        config.WikiDir = getenv("WIKIDIR", config.WikiDir)
        config.Logfile = getenv("LOGFILE", config.Logfile)
        config.EncryptionKey = getenv("ENCRYPTIONKEY", config.EncryptionKey)
        if len(config.EncryptionKey) == 0 </span><span class="cov0" title="0">{
                config.EncryptionKey = randstr.String(32)
                fmt.Printf("Generated EncryptionKey '%v' be sure to add to your config", config.EncryptionKey)
        }</span>

        // Make sure the path ends with a /
        <span class="cov0" title="0">if config.WikiDir[len(config.WikiDir)-1] != '/' </span><span class="cov0" title="0">{
                config.WikiDir = config.WikiDir + "/"
        }</span>

        <span class="cov0" title="0">if len(config.EncryptionKey) != 32 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Need to set EncryptionKey to be 32 char string not %v",
                        len(config.EncryptionKey))
        }</span>
        <span class="cov0" title="0">j, err := json.MarshalIndent(config, "", "   ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fmt.Print(string(j))

        return &amp;config, nil</span>

}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "log"
        "sort"
        "time"
)

type wikiNav struct {
        Name    string
        URL     string
        ID      string
        IsDir   bool
        SubNav  []wikiNav
        Mod     time.Time
        ModStr  string
        Summary string
}
type nav struct {
        Pages   []string
        Wikis   []wikiNav
        Tags    TagIndex
        Recents []wikiNav
}

type navFunc func(storage) nav

type byModTime []wikiNav

func (m byModTime) Len() int           <span class="cov8" title="1">{ return len(m) }</span>
func (m byModTime) Swap(i, j int)      <span class="cov8" title="1">{ m[i], m[j] = m[j], m[i] }</span>
func (m byModTime) Less(i, j int) bool <span class="cov8" title="1">{ return m[i].Mod.Before(m[j].Mod) }</span>

func contains(target string, in []string) bool <span class="cov0" title="0">{
        for _, d := range in </span><span class="cov0" title="0">{
                if target == d </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func flattenWikis(current []wikiNav) []wikiNav <span class="cov8" title="1">{
        var newList []wikiNav

        for _, v := range current </span><span class="cov8" title="1">{
                if v.IsDir </span><span class="cov8" title="1">{
                        newList = append(newList, flattenWikis(v.SubNav)...)
                }</span> else<span class="cov8" title="1"> {
                        newList = append(newList, v)
                }</span>
        }
        <span class="cov8" title="1">return newList</span>
}
func genRecents(current []wikiNav) []wikiNav <span class="cov8" title="1">{
        var newList []wikiNav

        newList = flattenWikis(current)
        sort.Sort(sort.Reverse(byModTime(newList)))

        return newList

}</span>
func getNav(s storage) nav <span class="cov0" title="0">{
        start := time.Now()
        wikis := s.IndexWikiFiles("", wikiDir)
        loadwikis := time.Now()
        tags := s.IndexTags(tagDir)
        loadtags := time.Now()
        indexedTags := s.IndexRawFiles(wikiDir, "PDF", tags)
        indexTags := time.Now()

        log.Printf("[nav] wikis %v", loadwikis.Sub(start))
        log.Printf("[nav] tags %v", loadtags.Sub(loadwikis))
        log.Printf("[nav] idxtags %v", indexTags.Sub(loadtags))
        return nav{
                Wikis:   wikis,
                Tags:    indexedTags,
                Recents: genRecents(wikis),
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "html/template"
        "log"
        "net/http"
        "regexp"
)

var validPubPath = regexp.MustCompile("^/pub/([a-zA-Z0-9\\.\\-_ /]*)$")

func makePubHandler(fn func(http.ResponseWriter, *http.Request, *wikiPage, storage), navfn navFunc, s storage) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                log.Printf("Path is : %v", r.URL.Path)
                m := validPubPath.FindStringSubmatch(r.URL.Path)
                if m == nil </span><span class="cov0" title="0">{
                        http.NotFound(w, r)
                        return
                }</span>
                <span class="cov0" title="0">title := m[1]
                p := &amp;wikiPage{basePage: basePage{Title: title}}
                fn(w, r, p, s)</span>
        }
}
func pubHandler(w http.ResponseWriter, r *http.Request, p *wikiPage, s storage) <span class="cov0" title="0">{
        p, err := convertMarkdown(s.getPage(p))
        if err != nil </span>{<span class="cov0" title="0">
        }</span> else<span class="cov0" title="0"> {
                p.Body = template.HTML(parseWikiWords([]byte(p.Body)))
        }</span>

        <span class="cov0" title="0">renderTemplate(w, "pub", p)</span>
}
func getPubNav(s storage) nav <span class="cov0" title="0">{
        return nav{
                Pages: s.getPublicPages(),
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import "strings"

// QueryResults is used to hold search results after a wiki search
type QueryResults struct {
        WikiName string
        LineNum  string
        Text     string
}

// ParseQueryResults converts a result string to a query result
func ParseQueryResults(source []string) []QueryResults <span class="cov8" title="1">{
        res := []QueryResults{}
        for _, r := range source </span><span class="cov8" title="1">{
                sub := strings.Split(r, "\t")
                if len(sub) &lt; 2 </span><span class="cov8" title="1">{
                        res = append(res, QueryResults{"ERROR", "", "Invalid query result"})
                        continue</span>
                }
                <span class="cov8" title="1">res = append(res, QueryResults{
                        WikiName: sub[0],
                        LineNum:  sub[1],
                        Text:     strings.Join(sub[2:], "\t"),
                })</span>

        }
        <span class="cov8" title="1">return res</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "errors"
        "io"
)

func encrypt(plaintext []byte, key []byte) ([]byte, error) <span class="cov8" title="1">{
        c, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">nonce := make([]byte, gcm.NonceSize())
        if _, err = io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return gcm.Seal(nonce, nonce, plaintext, nil), nil</span>
}

func decrypt(ciphertext []byte, key []byte) ([]byte, error) <span class="cov8" title="1">{
        c, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">nonceSize := gcm.NonceSize()
        if len(ciphertext) &lt; nonceSize </span><span class="cov0" title="0">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov8" title="1">nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
        return gcm.Open(nil, nonce, ciphertext, nil)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "bufio"
        "bytes"
        "fmt"
        "html/template"
        "io"
        "io/fs"
        "log"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"
)

const TIME_FORMAT = "2006-01-02 15:04:05"

type storage interface {
        storeFile(name string, content []byte) error
        deleteFile(name string) error
        moveFile(from, to string) error
        getPublicPages() []string
        getPage(p *wikiPage) (*wikiPage, error)
        searchPages(root, query string) []string
        checkForPDF(p *wikiPage) (*wikiPage, error)
        IndexTags(path string) TagIndex
        GetTagWikis(tag string) Tag
        IndexRawFiles(path, fileExtension string, existing TagIndex) TagIndex
        IndexWikiFiles(base, path string) []wikiNav
        getWikiList(from string) []string
        storeImage(wikiTitle string, imageData []byte, extension string) (string, error)
}

// StorageConfig holds configuration for file storage
type StorageConfig struct {
        WikiDir string
        TagDir  string
        PubDir  string
        EncKey  []byte
}

// ConfigurableStorage is a storage implementation that does not rely on global variables
type ConfigurableStorage struct {
        config StorageConfig
        fs     fileStorage
}

// NewConfigurableStorage creates a new configurable storage with the given config
func NewConfigurableStorage(config StorageConfig) *ConfigurableStorage <span class="cov8" title="1">{
        return &amp;ConfigurableStorage{
                config: config,
                fs:     fileStorage{TagDir: config.TagDir},
        }
}</span>

// Implement the storage interface methods for ConfigurableStorage
func (cs *ConfigurableStorage) storeFile(name string, content []byte) error <span class="cov8" title="1">{
        return cs.fs.storeFile(name, content)
}</span>

func (cs *ConfigurableStorage) deleteFile(name string) error <span class="cov0" title="0">{
        return cs.fs.deleteFile(name)
}</span>

func (cs *ConfigurableStorage) moveFile(from, to string) error <span class="cov0" title="0">{
        return cs.fs.moveFile(from, to)
}</span>

func (cs *ConfigurableStorage) getPublicPages() []string <span class="cov0" title="0">{
        // Replace global pubDir with config.PubDir
        originalPubDir := pubDir
        pubDir = cs.config.PubDir
        defer func() </span><span class="cov0" title="0">{ pubDir = originalPubDir }</span>()
        
        <span class="cov0" title="0">return cs.fs.getPublicPages()</span>
}

func (cs *ConfigurableStorage) getPage(p *wikiPage) (*wikiPage, error) <span class="cov8" title="1">{
        // Replace globals with config values
        originalWikiDir := wikiDir
        originalTagDir := tagDir
        originalPubDir := pubDir
        originalEkey := ekey
        
        wikiDir = cs.config.WikiDir
        tagDir = cs.config.TagDir
        pubDir = cs.config.PubDir
        ekey = cs.config.EncKey
        
        defer func() </span><span class="cov8" title="1">{
                wikiDir = originalWikiDir
                tagDir = originalTagDir
                pubDir = originalPubDir
                ekey = originalEkey
        }</span>()
        
        <span class="cov8" title="1">return cs.fs.getPage(p)</span>
}

func (cs *ConfigurableStorage) searchPages(root, query string) []string <span class="cov0" title="0">{
        return cs.fs.searchPages(root, query)
}</span>

func (cs *ConfigurableStorage) checkForPDF(p *wikiPage) (*wikiPage, error) <span class="cov0" title="0">{
        // Replace wikiDir with config.WikiDir
        originalWikiDir := wikiDir
        wikiDir = cs.config.WikiDir
        defer func() </span><span class="cov0" title="0">{ wikiDir = originalWikiDir }</span>()
        
        <span class="cov0" title="0">return cs.fs.checkForPDF(p)</span>
}

func (cs *ConfigurableStorage) IndexTags(path string) TagIndex <span class="cov0" title="0">{
        return cs.fs.IndexTags(path)
}</span>

func (cs *ConfigurableStorage) GetTagWikis(tag string) Tag <span class="cov0" title="0">{
        return cs.fs.GetTagWikis(tag)
}</span>

func (cs *ConfigurableStorage) IndexRawFiles(path, fileExtension string, existing TagIndex) TagIndex <span class="cov0" title="0">{
        return cs.fs.IndexRawFiles(path, fileExtension, existing)
}</span>

func (cs *ConfigurableStorage) IndexWikiFiles(base, path string) []wikiNav <span class="cov0" title="0">{
        return cs.fs.IndexWikiFiles(base, path)
}</span>

func (cs *ConfigurableStorage) getWikiList(from string) []string <span class="cov0" title="0">{
        // Replace wikiDir with config.WikiDir
        originalWikiDir := wikiDir
        wikiDir = cs.config.WikiDir
        defer func() </span><span class="cov0" title="0">{ wikiDir = originalWikiDir }</span>()
        
        <span class="cov0" title="0">return cs.fs.getWikiList(from)</span>
}

func (cs *ConfigurableStorage) storeImage(wikiTitle string, imageData []byte, extension string) (string, error) <span class="cov8" title="1">{
        // Replace wikiDir with config.WikiDir
        originalWikiDir := wikiDir
        wikiDir = cs.config.WikiDir
        defer func() </span><span class="cov8" title="1">{ wikiDir = originalWikiDir }</span>()
        
        <span class="cov8" title="1">return cs.fs.storeImage(wikiTitle, imageData, extension)</span>
}

type fileStorage struct {
        TagDir string
}

func createDir(filename string) error <span class="cov8" title="1">{
        dir := filepath.Dir(filename)
        if dir != "" </span><span class="cov8" title="1">{
                err := os.MkdirAll(dir, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
func (fst *fileStorage) storeFile(name string, content []byte) error <span class="cov8" title="1">{
        err := createDir(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = os.WriteFile(name, content, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (fst *fileStorage) deleteFile(name string) error <span class="cov8" title="1">{
        if err := os.Remove(name); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
func (fst *fileStorage) moveFile(from, to string) error <span class="cov8" title="1">{
        if err := os.Rename(from, to); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func indexPubPages(path string) []string <span class="cov8" title="1">{

        var results []string

        err := filepath.WalkDir(path, func(subpath string, info fs.DirEntry, _ error) error </span><span class="cov8" title="1">{
                if !info.IsDir() </span><span class="cov8" title="1">{
                        results = append(results, strings.TrimPrefix(subpath, path))
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">checkErr(err)

        return results</span>
}

func (fst *fileStorage) getPublicPages() []string <span class="cov8" title="1">{
        return indexPubPages(pubDir)
}</span>

func (fst *fileStorage) getPage(p *wikiPage) (*wikiPage, error) <span class="cov8" title="1">{
        filename := getWikiFilename(wikiDir, p.Title)

        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                log.Println(err)
                return p, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        body, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return p, err
        }</span>
        <span class="cov8" title="1">if bytes.HasPrefix(body, encryptionFlag) </span><span class="cov8" title="1">{
                tmp := bytes.TrimPrefix(body, encryptionFlag)

                body, err = decrypt(tmp, ekey)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                        return p, err
                }</span>
                <span class="cov8" title="1">p.Encrypted = true</span>
        }
        <span class="cov8" title="1">p.Body = template.HTML(body)

        info, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return p, err
        }</span>

        <span class="cov8" title="1">p.Modified = info.ModTime().String()

        tags, err := os.ReadFile(getWikiTagsFilename(p.Title))
        if err == nil </span><span class="cov8" title="1">{
                p.Tags = string(tags)
                p.TagArray = strings.Split(p.Tags, ",")
        }</span>

        <span class="cov8" title="1">pubfilename := getWikiPubFilename(p.Title)

        pubfile, err := os.Open(pubfilename)
        if err == nil </span><span class="cov8" title="1">{
                p.Published = true
                pubfile.Close()
        }</span>

        <span class="cov8" title="1">return p, nil</span>
}

func (fst *fileStorage) searchPages(root string, query string) []string <span class="cov8" title="1">{
        var wg sync.WaitGroup
        results := make(chan string)

        filepath.WalkDir(root, func(path string, file fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                if !file.IsDir() </span><span class="cov8" title="1">{
                        wg.Add(1)
                        name := strings.TrimSuffix(strings.TrimPrefix(path, root), ".md")
                        go readFile(&amp;wg, name, path, query, results)
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(results)
        }</span>()

        <span class="cov8" title="1">hits := []string{}
        for res := range results </span><span class="cov8" title="1">{
                hits = append(hits, res)
        }</span>
        <span class="cov8" title="1">return hits</span>
}
func readFile(wg *sync.WaitGroup, name string, path string, query string, results chan string) <span class="cov8" title="1">{
        defer wg.Done()

        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()
        scanner := bufio.NewScanner(file)
        for i := 1; scanner.Scan(); i++ </span><span class="cov8" title="1">{
                if strings.Contains(scanner.Text(), query) </span><span class="cov8" title="1">{
                        match := fmt.Sprintf("%s\t%d\t%s\n", name, i, scanner.Text())
                        results &lt;- match
                }</span>
        }
}

func (fst *fileStorage) checkForPDF(p *wikiPage) (*wikiPage, error) <span class="cov8" title="1">{
        filename := getPDFFilename(wikiDir, p.Title)

        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Failed to open %v, %v\n", p.Title, err.Error())
                return p, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        p.Body = template.HTML(fmt.Sprintf("&lt;a href=\"/wiki/raw/%v\"&gt;%v&lt;/a&gt;", p.Title, p.Title))
        return p, nil</span>
}

// IndexTags reads tags files from the file system and constructs
// an index
func (fst *fileStorage) IndexTags(path string) TagIndex <span class="cov8" title="1">{
        index := TagIndex(make(map[string]Tag))

        err := filepath.WalkDir(path, func(subpath string, info fs.DirEntry, _ error) error </span><span class="cov8" title="1">{
                if !info.IsDir() &amp;&amp; !strings.HasPrefix(info.Name(), ".") </span><span class="cov8" title="1">{
                        contents, err := os.ReadFile(subpath)
                        checkErr(err)

                        wikiName := strings.TrimPrefix(subpath, path)
                        for _, t := range GetTagsFromString(string(contents)) </span><span class="cov8" title="1">{
                                index.AssociateTagToWiki(wikiName, t)
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">checkErr(err)

        return index</span>
}
func (fst *fileStorage) GetTagWikis(tag string) Tag <span class="cov0" title="0">{
        ti := fst.IndexTags(fst.TagDir)
        return ti[tag]
}</span>

// IndexRawFiles adds in tags for a file extension tag
func (fst *fileStorage) IndexRawFiles(path, fileExtension string, existing TagIndex) TagIndex <span class="cov8" title="1">{

        err := filepath.WalkDir(path, func(subpath string, info fs.DirEntry, _ error) error </span><span class="cov8" title="1">{
                if strings.HasSuffix(strings.ToLower(info.Name()), strings.ToLower(fileExtension)) </span><span class="cov0" title="0">{
                        filename := strings.TrimPrefix(subpath, path)
                        existing.AssociateTagToWiki(filename, fileExtension)
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">checkErr(err)

        return existing</span>

}

func genID(base, name string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(base+name, "/", "-")
}</span>

// IndexWikiFiles will crawl through picking out files that conform to requirements for wiki entries
// This includes md and pdf files.
// Any hidden (dot) files are skipped
// Folders are included as part of the path
// Mod time is used to order the files
func (fst *fileStorage) IndexWikiFiles(base, path string) []wikiNav <span class="cov8" title="1">{
        files, err := os.ReadDir(path)
        checkErr(err)

        var names []wikiNav
        for _, f := range files </span><span class="cov8" title="1">{

                if f.IsDir() &amp;&amp; contains(f.Name(), specialDir) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(f.Name(), ".") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">info, err := f.Info()
                checkErr(err)

                // Ignore anything that isnt an md file
                if strings.HasSuffix(f.Name(), ".md") </span><span class="cov8" title="1">{
                        name := strings.TrimSuffix(f.Name(), ".md")
                        tmp := wikiNav{
                                Name:    name,
                                URL:     base + "/" + name,
                                Mod:     info.ModTime(),
                                ModStr:  info.ModTime().Format(TIME_FORMAT),
                                ID:      genID(base, name),
                                Summary: "This is a test summary for markdown",
                        }
                        names = append(names, tmp)
                }</span>
                <span class="cov8" title="1">if strings.HasSuffix(f.Name(), ".txt") </span><span class="cov8" title="1">{
                        name := strings.TrimSuffix(f.Name(), ".txt")
                        tmp := wikiNav{
                                Name:    name,
                                URL:     base + "/" + name,
                                Mod:     info.ModTime(),
                                ModStr:  info.ModTime().Format(TIME_FORMAT),
                                ID:      genID(base, name),
                                Summary: "This is a test summary for text file",
                        }
                        names = append(names, tmp)
                }</span>
                <span class="cov8" title="1">if strings.HasSuffix(f.Name(), ".pdf") </span><span class="cov0" title="0">{
                        tmp := wikiNav{
                                Name:   f.Name(),
                                URL:    base + "/" + f.Name(),
                                Mod:    info.ModTime(),
                                ModStr: info.ModTime().Format(TIME_FORMAT),
                                ID:     genID(base, f.Name()),
                        }
                        names = append(names, tmp)
                }</span>
                <span class="cov8" title="1">if f.IsDir() </span><span class="cov0" title="0">{
                        newbase := base + "/" + info.Name()
                        tmp := wikiNav{
                                Name:  f.Name(),
                                URL:   newbase,
                                IsDir: true,
                                ID:    genID(base, f.Name()),
                        }
                        tmp.SubNav = fst.IndexWikiFiles(newbase, path+"/"+f.Name())
                        if len(tmp.SubNav) &gt; 0 </span><span class="cov0" title="0">{
                                // Override the dir's mod time with the first entry
                                tmp.Mod = tmp.SubNav[0].Mod
                        }</span>
                        <span class="cov0" title="0">names = append(names, tmp)</span>
                }
        }

        <span class="cov8" title="1">sort.Sort(sort.Reverse(byModTime(names)))
        return names</span>

}

func (fst *fileStorage) getWikiList(from string) []string <span class="cov8" title="1">{
        path := wikiDir + from

        var results []string

        err := filepath.WalkDir(path, func(subpath string, info fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        log.Print("getWikiList", err)
                        return nil
                }</span>
                <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                        tmp := strings.TrimPrefix(subpath, wikiDir)
                        tmp = strings.TrimSuffix(tmp, ".md")
                        results = append(results, tmp)
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">checkErr(err)

        return results</span>
}

// storeImage saves an image to the wiki's images directory
func (fst *fileStorage) storeImage(wikiTitle string, imageData []byte, extension string) (string, error) <span class="cov8" title="1">{
        // Create images directory if needed
        imagesDir := filepath.Join(wikiDir, "images", wikiTitle)
        if err := os.MkdirAll(imagesDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        // Generate unique filename with timestamp
        <span class="cov8" title="1">timestamp := fmt.Sprintf("%d", time.Now().UnixNano())
        filename := timestamp + extension
        filepath := filepath.Join(imagesDir, filename)
        
        // Save file
        if err := os.WriteFile(filepath, imageData, 0644); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        // Return URL to client
        <span class="cov8" title="1">imageURL := fmt.Sprintf("/wiki/raw/images/%s/%s", wikiTitle, filename)
        return imageURL, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import "log"

type cachedStorage struct {
        fileStorage
        wikiDir         string
        tagDir          string
        cachedTagIndex  TagIndex
        cachedRawFiles  TagIndex
        cachedWikiIndex []wikiNav
}

func newCachedStorage(fs fileStorage, wd, td string) cachedStorage <span class="cov0" title="0">{
        ti := fs.IndexTags(td)
        rf := fs.IndexRawFiles(wd, "PDF", ti)
        wi := fs.IndexWikiFiles("", wd)

        return cachedStorage{fs, wd, td, ti, rf, wi}
}</span>

func (cs *cachedStorage) rebuildCache() <span class="cov8" title="1">{
        log.Println("[cache] wiki cache rebuild")
        cs.cachedTagIndex = cs.fileStorage.IndexTags(cs.tagDir)
        cs.cachedRawFiles = cs.fileStorage.IndexRawFiles(cs.wikiDir, "PDF", cs.cachedTagIndex)
        cs.cachedWikiIndex = cs.fileStorage.IndexWikiFiles("", cs.wikiDir)
}</span>

func (cs *cachedStorage) IndexWikiFiles(base, path string) []wikiNav <span class="cov8" title="1">{
        return cs.cachedWikiIndex
}</span>

func (cs *cachedStorage) IndexTags(path string) TagIndex <span class="cov8" title="1">{
        return cs.cachedTagIndex
}</span>

func (cs *cachedStorage) IndexRawFiles(path, fileExtension string, existing TagIndex) TagIndex <span class="cov8" title="1">{
        return cs.cachedRawFiles
}</span>

func (cs *cachedStorage) clearCache() error <span class="cov8" title="1">{
        // Original async implementation - rebuilds cache in background
        go cs.rebuildCache()
        return nil
}</span>
func (cs *cachedStorage) storeFile(name string, content []byte) error <span class="cov8" title="1">{
        if err := cs.fileStorage.storeFile(name, content); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return cs.clearCache()</span>
}
func (cs *cachedStorage) deleteFile(name string) error <span class="cov8" title="1">{
        if err := cs.fileStorage.deleteFile(name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return cs.clearCache()</span>
}
func (cs *cachedStorage) moveFile(from, to string) error <span class="cov8" title="1">{
        if err := cs.fileStorage.moveFile(from, to); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return cs.clearCache()</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

type stubStorage struct {
        page            wikiPage
        expectederr     error
        GetTagWikisFunc func(string) Tag
        getPageFunc     func(*wikiPage) (*wikiPage, error)
        storeFileFunc   func(string, []byte) error
        storeImageFunc  func(string, []byte, string) (string, error)
        loggerFunc      func(string)
}

func (ss *stubStorage) logit(method string) <span class="cov8" title="1">{
        if ss.loggerFunc != nil </span><span class="cov8" title="1">{
                ss.loggerFunc(method)
        }</span>
}

func (ss *stubStorage) storeFile(name string, content []byte) error <span class="cov8" title="1">{
        return ss.storeFileFunc(name, content)
}</span>
func (ss *stubStorage) deleteFile(name string) error <span class="cov8" title="1">{
        ss.logit("deleteFile")
        return nil
}</span>
func (ss *stubStorage) moveFile(from, to string) error <span class="cov8" title="1">{
        ss.logit("moveFile")
        return nil
}</span>
func (ss *stubStorage) getWikiList(from string) []string <span class="cov8" title="1">{
        ss.logit("getWikiList")
        return []string{"test1", "test2"}
}</span>

func (ss *stubStorage) getPublicPages() []string <span class="cov0" title="0">{
        return []string{}
}</span>

func (ss *stubStorage) getPage(p *wikiPage) (*wikiPage, error) <span class="cov8" title="1">{
        return ss.getPageFunc(p)
}</span>

func (ss *stubStorage) searchPages(root, query string) []string <span class="cov8" title="1">{
        return []string{}
}</span>

func (ss *stubStorage) checkForPDF(p *wikiPage) (*wikiPage, error) <span class="cov8" title="1">{
        return &amp;ss.page, ss.expectederr
}</span>
func (ss *stubStorage) IndexTags(path string) TagIndex <span class="cov0" title="0">{
        return nil
}</span>
func (ss *stubStorage) IndexRawFiles(path, fileExtension string, existing TagIndex) TagIndex <span class="cov0" title="0">{
        return nil
}</span>
func (ss *stubStorage) GetTagWikis(tag string) Tag <span class="cov8" title="1">{
        return ss.GetTagWikisFunc(tag)
}</span>
func (ss *stubStorage) IndexWikiFiles(base, path string) []wikiNav <span class="cov0" title="0">{
        return nil
}</span>

func (ss *stubStorage) storeImage(wikiTitle string, imageData []byte, extension string) (string, error) <span class="cov0" title="0">{
        if ss.storeImageFunc != nil </span><span class="cov0" title="0">{
                return ss.storeImageFunc(wikiTitle, imageData, extension)
        }</span>
        <span class="cov0" title="0">ss.logit("storeImage")
        return "/wiki/raw/images/" + wikiTitle + "/test.png", nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import "strings"

// Tag used to store a tag and associated wiki titles
type Tag struct {
        TagName string
        Wikis   []string
}

// GetWikisForTag returns a list of wikis for a tag
func (t *Tag) GetWikisForTag() []string <span class="cov8" title="1">{
        return t.Wikis
}</span>

// AddWiki adds a wiki title to the tag
func (t *Tag) AddWiki(wiki string) <span class="cov8" title="1">{
        t.Wikis = append(t.Wikis, wiki)
}</span>

// GetTagsFromString takes a string of comma separated tags and converts to
// a slice of tag structs
func GetTagsFromString(tagstring string) []string <span class="cov8" title="1">{
        // Calling split on empty seems to give you a slice with an empty string
        // so need to manually check before going ahead with the split and return a
        // empty slice
        if tagstring == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov8" title="1">tagnames := strings.Split(tagstring, ",")

        return tagnames</span>
}

// TagIndex holds a list of tag objects and allows adding of wiki data
type TagIndex map[string]Tag

// AssociateTagToWiki adds a wiki page to a tag in the index
func (t TagIndex) AssociateTagToWiki(wiki, tag string) <span class="cov8" title="1">{
        tag = strings.TrimSpace(tag)
        val, exists := t[tag]
        if !exists </span><span class="cov8" title="1">{
                val = Tag{TagName: tag}
        }</span>
        <span class="cov8" title="1">val.AddWiki(wiki)
        t[tag] = val</span>

}

// GetTag returns the Tag from the tag index
func (t TagIndex) GetTag(tag string) Tag <span class="cov8" title="1">{
        return t[tag]
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "html/template"
        "log"
        "net/http"
        "os"
        "regexp"
        "strconv"
        "strings"
        "time"

        md "github.com/JohannesKaufmann/html-to-markdown"
        "github.com/microcosm-cc/bluemonday"
        "github.com/russross/blackfriday"
)

var (
        wikiDir        string
        tagDir         string
        pubDir         string
        ekey           []byte
        encryptionFlag = []byte("ENCRYPTED")
        specialDir     []string
)

type basePage struct {
        Title string
        Nav   nav
}

type wikiPage struct {
        Body      template.HTML
        Tags      string
        TagArray  []string
        Created   string
        Modified  string
        Published bool
        Encrypted bool
        basePage
        Index []string
}

type searchPage struct {
        basePage
        Results []QueryResults
}

type mdConverter interface {
        ConvertURL(string) (string, error)
}

func checkErr(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func getPDFFilename(folder, name string) string <span class="cov8" title="1">{
        return folder + name
}</span>

func getWikiFilename(folder, name string) string <span class="cov8" title="1">{
        return folder + name + ".md"
}</span>

func getWikiTagsFilename(name string) string <span class="cov8" title="1">{
        return tagDir + name
}</span>

func getWikiPubFilename(name string) string <span class="cov8" title="1">{
        return pubDir + name
}</span>

func (p *wikiPage) save(s storage) error <span class="cov8" title="1">{
        filename := getWikiFilename(wikiDir, p.Title)
        body := []byte(p.Body)
        if p.Encrypted </span><span class="cov0" title="0">{
                var err error
                body, err = encrypt(body, ekey)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">body = append(encryptionFlag, body...)</span>
        }
        <span class="cov8" title="1">if err := s.storeFile(filename, body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tagsfile := getWikiTagsFilename(p.Title)
        if err := s.storeFile(tagsfile, []byte(p.Tags)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pubfile := getWikiPubFilename(p.Title)
        if p.Published </span><span class="cov8" title="1">{
                if err := s.storeFile(pubfile, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                if err := s.deleteFile(pubfile); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func convertMarkdown(page *wikiPage, err error) (*wikiPage, error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                return page, err
        }</span>

        <span class="cov8" title="1">p := bluemonday.UGCPolicy()
        p.AllowAttrs("class").Matching(regexp.MustCompile("^language-[a-zA-Z0-9]+$")).OnElements("code")

        page.Body = template.HTML(regexp.MustCompile("\r\n").ReplaceAllString(string(page.Body), "\n"))

        unsafe := blackfriday.Run([]byte(page.Body),
                blackfriday.WithExtensions(
                        blackfriday.CommonExtensions|
                                blackfriday.HardLineBreak|
                                blackfriday.HeadingIDs|
                                blackfriday.AutoHeadingIDs,
                ),
        )

        page.Body = template.HTML(p.SanitizeBytes(unsafe))
        return page, nil</span>
}

func viewHandler(w http.ResponseWriter, r *http.Request, p *wikiPage, s storage) <span class="cov8" title="1">{
        p, err := convertMarkdown(s.getPage(p))
        if err != nil </span><span class="cov8" title="1">{
                p, err = s.checkForPDF(p)
                if err != nil </span><span class="cov8" title="1">{
                        http.Redirect(w, r, "/wiki/edit/"+p.Title, http.StatusFound)
                        return
                }</span>
        } else<span class="cov8" title="1"> {
                p.Body = template.HTML(parseWikiWords([]byte(p.Body)))
        }</span>

        <span class="cov8" title="1">renderTemplate(w, "view", p)</span>
}

func editHandler(w http.ResponseWriter, r *http.Request, p *wikiPage, s storage) <span class="cov8" title="1">{
        p, _ = s.getPage(p)
        renderTemplate(w, "edit", p)
}</span>

func makeSearchHandler(fn navFunc, s storage) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                term := r.URL.Query().Get("term")
                if term == "" </span><span class="cov0" title="0">{
                        http.NotFound(w, r)
                        return
                }</span>

                <span class="cov8" title="1">results := ParseQueryResults(s.searchPages(wikiDir, term))
                p := &amp;searchPage{Results: results, basePage: basePage{Title: "Search", Nav: fn(s)}}

                renderTemplate(w, "search", p)</span>
        }
}

func simpleHandler(page string, fn navFunc, s storage) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                renderTemplate(w, page, fn(s))
        }</span>
}

func saveHandler(w http.ResponseWriter, r *http.Request, wiki string, s storage) string <span class="cov8" title="1">{
        body := r.FormValue("body")
        body = regexp.MustCompile("\r\n").ReplaceAllString(body, "\n")

        p := wikiPage{basePage: basePage{Title: wiki}, Body: template.HTML(body), Tags: r.FormValue("wikitags")}
        if r.FormValue("wikipub") == "on" </span><span class="cov8" title="1">{
                p.Published = true
        }</span>
        <span class="cov8" title="1">if r.FormValue("wikicrypt") == "on" </span><span class="cov0" title="0">{
                p.Encrypted = true
        }</span>

        <span class="cov8" title="1">if err := p.save(s); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error saving wiki page: %v", err) // Add logging here
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return ""
        }</span>
        <span class="cov8" title="1">http.Redirect(w, r, "/wiki/view/"+p.Title, http.StatusFound)

        return r.FormValue("wikitags")</span>
}

func deleteHandler(w http.ResponseWriter, r *http.Request, p *wikiPage, s storage) <span class="cov8" title="1">{
        filename := getWikiFilename(wikiDir, p.Title)

        if err := s.deleteFile(filename); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">tagsfile := getWikiTagsFilename(p.Title)
        if err := s.deleteFile(tagsfile); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">http.Redirect(w, r, "/wiki", http.StatusFound)</span>
}

func moveHandler(w http.ResponseWriter, r *http.Request, p *wikiPage, s storage) <span class="cov8" title="1">{
        from := getWikiFilename(wikiDir, p.Title)
        to := r.FormValue("to")
        if to == "" </span><span class="cov0" title="0">{
                http.Error(w, "Form param 'to' needs setting", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">tofile := getWikiFilename(wikiDir, to)

        if err := s.moveFile(from, tofile); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">tagsfile := getWikiTagsFilename(p.Title)
        totags := getWikiTagsFilename(to)
        if err := s.moveFile(tagsfile, totags); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">http.Redirect(w, r, "/wiki/view/"+to, http.StatusFound)</span>
}

func scrapeHandler(w http.ResponseWriter, r *http.Request, mdc mdConverter, st storage) <span class="cov8" title="1">{
        url := r.FormValue("url")
        name := r.FormValue("target")

        body, err := mdc.ConvertURL(url)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        // TODO Pass in file store and then when convert is called save to a new file
        // Need a means of determining where to save the file to...perhaps whatever is
        // specified - that should work for folders, etc already :-)
        <span class="cov8" title="1">p := wikiPage{basePage: basePage{Title: name}, Body: template.HTML(body), Tags: "Scraped"}

        if err := p.save(st); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">http.Redirect(w, r, "/wiki/view/"+name, http.StatusFound)</span>
}

var templates = template.Must(template.ParseFiles(
        "views/edit.html",
        "views/view.html",
        "views/pub.html",
        "views/pubhome.html",
        "views/home.html",
        "views/list.html",
        "views/search.html",
        "views/index.html",
        "views/footer.html",
        "views/recents.html",
        "views/leftnav.html"))

func renderTemplate(w http.ResponseWriter, tmpl string, p interface{}) <span class="cov8" title="1">{
        if err := templates.ExecuteTemplate(w, tmpl+".html", p); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
        }</span>
}

var validPath = regexp.MustCompile(`^/wiki/(edit|save|view|search|delete|move|scrape)/([a-zA-Z0-9\.\-_ /]*)$`)

func makeHandler(fn func(http.ResponseWriter, *http.Request, *wikiPage, storage), navfn navFunc, s storage) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                wword := r.URL.Query().Get("wword")
                if wword == "" </span><span class="cov0" title="0">{
                        m := validPath.FindStringSubmatch(r.URL.Path)
                        if m == nil </span><span class="cov0" title="0">{
                                http.NotFound(w, r)
                                return
                        }</span>
                        <span class="cov0" title="0">wword = m[2]</span>
                }
                <span class="cov0" title="0">p := &amp;wikiPage{basePage: basePage{Title: wword, Nav: navfn(s)}}
                fn(w, r, p, s)</span>
        }
}

func makeScrapeHandler(fn func(http.ResponseWriter, *http.Request, mdConverter, storage), mdc mdConverter, fs storage) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                fn(w, r, mdc, fs)
        }</span>
}

func processSave(fn func(http.ResponseWriter, *http.Request, string, storage) string, s storage) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m := validPath.FindStringSubmatch(r.URL.Path)
                if m == nil </span><span class="cov0" title="0">{
                        http.NotFound(w, r)
                        return
                }</span>
                <span class="cov0" title="0">fn(w, r, m[2], s)</span>
        }
}

func parseWikiWords(target []byte) []byte <span class="cov8" title="1">{
        var wikiWord = regexp.MustCompile(`\{\{([^\}^#]+)[#]*(.*)\}\}`)
        return wikiWord.ReplaceAll(target, []byte("&lt;a href=\"/wiki/view/$1#$2\"&gt;$1&lt;/a&gt;"))
}</span>

func loggingHandler(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                next.ServeHTTP(w, r)
                log.Printf("[%s] %q %v\n", r.Method, r.URL.String(), time.Since(start))
        }</span>)
}

func main() <span class="cov0" title="0">{
        specialDir = []string{"tags", "pub"}
        config, err := LoadConfig()
        checkErr(err)

        if config.Logfile != "" </span><span class="cov0" title="0">{
                f, err := os.OpenFile(config.Logfile, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
                checkErr(err)
                defer f.Close()
                log.SetOutput(f)
        }</span>

        <span class="cov0" title="0">wikiDir = strings.TrimSuffix(config.WikiDir, "/") + "/"
        tagDir = wikiDir + "tags/"
        pubDir = wikiDir + "pub/"
        ekey = []byte(config.EncryptionKey)

        os.MkdirAll(tagDir, 0755)
        os.MkdirAll(pubDir, 0755)

        httpmux := http.NewServeMux()
        
        // Option 1: Using original cached storage
        cached := newCachedStorage(fileStorage{tagDir}, wikiDir, tagDir)
        fstore := &amp;cached
        
        // Option 2: Using new configurable storage wrapped with caching (currently commented out)
        /*
        storageConfig := StorageConfig{
                WikiDir: wikiDir,
                TagDir:  tagDir,
                PubDir:  pubDir,
                EncKey:  ekey,
        }
        configStore := NewConfigurableStorage(storageConfig)
        // Wrap in cached storage to maintain caching functionality
        cached := newCachedStorage(configStore.fs, configStore.config.WikiDir, configStore.config.TagDir)
        fstore := &amp;cached
        */
        
        htmltomd := md.NewConverter("", true, nil)

        httpmux.Handle("/wiki", loggingHandler(simpleHandler("home", getNav, fstore)))
        httpmux.Handle("/wiki/list/", loggingHandler(simpleHandler("list", getNav, fstore)))
        httpmux.Handle("/wiki/search/", loggingHandler(makeSearchHandler(getNav, fstore)))
        httpmux.Handle("/wiki/view/", loggingHandler(makeHandler(viewHandler, getNav, fstore)))
        httpmux.Handle("/wiki/edit/", loggingHandler(makeHandler(editHandler, getNav, fstore)))
        httpmux.Handle("/wiki/save/", loggingHandler(processSave(saveHandler, fstore)))
        httpmux.Handle("/wiki/delete/", loggingHandler(makeHandler(deleteHandler, getNav, fstore)))
        httpmux.Handle("/wiki/move/", loggingHandler(makeHandler(moveHandler, getNav, fstore)))
        httpmux.Handle("/wiki/scrape/", loggingHandler(makeScrapeHandler(scrapeHandler, htmltomd, fstore)))
        httpmux.Handle("/wiki/raw/", http.StripPrefix("/wiki/raw/", http.FileServer(http.Dir(wikiDir))))
        httpmux.Handle("/pub/", loggingHandler(makePubHandler(pubHandler, getNav, fstore)))
        httpmux.Handle("/pub", loggingHandler(simpleHandler("pubhome", getPubNav, fstore)))
        httpmux.Handle("/api/", loggingHandler(apiHandler(innerAPIHandler, fstore)))
        httpmux.Handle("/api", loggingHandler(apiHandler(innerAPIHandler, fstore)))
        httpmux.Handle("/", http.FileServer(http.Dir("wwwroot")))
        httpmux.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("static"))))

        checkErr(http.ListenAndServe(":"+strconv.Itoa(config.HTTPPort), httpmux))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
